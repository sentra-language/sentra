// Advanced functions and closures in Sentra

// Higher-order function
fn map(arr, f) {
    let result = []
    for item in arr {
        result.push(f(item))
    }
    return result
}

// Lambda/arrow function
let square = fn(x) => x * x
let numbers = [1, 2, 3, 4, 5]
let squared = map(numbers, square)
log("Squared: " + squared)

// Note: Full closures with mutable capture not yet supported
// Using global state for demonstration
let globalCount1 = 0
let globalCount2 = 0

fn makeCounter1() {
    globalCount1 = globalCount1 + 1
    return globalCount1
}

fn makeCounter2() {
    globalCount2 = globalCount2 + 1
    return globalCount2
}

log("Counter1: " + makeCounter1()) // 1
log("Counter1: " + makeCounter1()) // 2
log("Counter2: " + makeCounter2()) // 1
log("Counter1: " + makeCounter1()) // 3

// Function composition (simplified)
fn addOne(x) {
    return x + 1
}

fn double(x) {
    return x * 2
}

fn addOneThenDouble(x) {
    return double(addOne(x))
}

log("5 + 1 then * 2 = " + addOneThenDouble(5)) // 12

// Recursive function (memoization simplified)
let fibCache = {}

fn fib(n) {
    if n <= 1 {
        return n
    }
    if fibCache[n] != null {
        return fibCache[n]
    }
    let result = fib(n - 1) + fib(n - 2)
    fibCache[n] = result
    return result
}

log("Fibonacci(10): " + fib(10))

// Partial application (simplified)
fn add(a, b) {
    return a + b
}

fn add5(b) {
    return add(5, b)
}

log("5 + 10 = " + add5(10)) // 15