#!/usr/bin/env sentra
// Sentra Runtime Error Handling Demonstration
// This script showcases defensive programming to prevent runtime errors

log("üõ°Ô∏è  Sentra Runtime Error Handling Demo")
log("=" * 50)

log("\nüöÄ Starting error handling demonstration...")
log("Note: This demonstrates defensive programming to prevent runtime errors")

// Safe division function that checks for zero
fn safe_divide(a, b) {
    if (b == 0) {
        log("‚ö†Ô∏è  Warning: Division by zero prevented")
        return null
    }
    return a / b
}

log("\n1Ô∏è‚É£  Safe Division Test:")
let result1 = safe_divide(42, 2)
log("42 / 2 = " + str(result1))

let result2 = safe_divide(42, 0)
if (result2 == null) {
    log("‚úÖ Successfully handled division by zero")
} else {
    log("Result: " + str(result2))
}

// Safe array access function
fn safe_array_access(arr, index) {
    if (index < 0 || index >= len(arr)) {
        log("‚ö†Ô∏è  Warning: Array index " + str(index) + " out of bounds for array of length " + str(len(arr)))
        return null
    }
    return arr[index]
}

log("\n2Ô∏è‚É£  Safe Array Access Test:")
let numbers = [10, 20, 30, 40, 50]
log("Array: " + str(numbers))

let valid_access = safe_array_access(numbers, 2)
log("Valid access [2]: " + str(valid_access))

let invalid_access = safe_array_access(numbers, 99)
if (invalid_access == null) {
    log("‚úÖ Successfully handled out of bounds access")
}

// Validation functions
fn validate_number(value) {
    if (type(value) != "number") {
        log("‚ö†Ô∏è  Warning: Expected number, got " + type(value))
        return false
    }
    return true
}

fn validate_string(value) {
    if (type(value) != "string") {
        log("‚ö†Ô∏è  Warning: Expected string, got " + type(value))
        return false
    }
    return true
}

log("\n3Ô∏è‚É£  Type Validation Test:")
let text = "Hello"
let number = 42

if (validate_string(text)) {
    log("‚úÖ String validation passed: " + text)
}

if (validate_number(number)) {
    log("‚úÖ Number validation passed: " + str(number))
}

// Test with wrong types
let text_is_number = validate_number(text)
if (text_is_number == false) {
    log("‚úÖ Successfully caught type mismatch")
}

// Safe map access - simplified version without iteration
fn safe_get_host(config) {
    // We know the structure, so we can check safely
    if (str(config) == "{}") {
        log("‚ö†Ô∏è  Warning: Empty configuration")
        return null
    }
    // In a real scenario, we'd have better ways to check key existence
    return "localhost"  // Simulated safe access
}

log("\n4Ô∏è‚É£  Safe Configuration Access Test:")
let config = {
    "host": "localhost",
    "port": 8080,
    "ssl": true
}
log("Config: " + str(config))

let host = safe_get_host(config)
if (host != null) {
    log("‚úÖ Successfully accessed host: " + host)
}

// Function existence check
fn function_exists(func_name) {
    // In a real implementation, this would check if function exists
    // For now, we'll simulate it
    let known_functions = ["log", "str", "len", "type"]
    for i in known_functions {
        if (i == func_name) {
            return true
        }
    }
    return false
}

log("\n5Ô∏è‚É£  Function Existence Test:")
if (function_exists("log")) {
    log("‚úÖ Function 'log' exists")
} else {
    log("‚ö†Ô∏è  Function 'log' not found")
}

let undefined_func_exists = function_exists("undefined_function")
if (undefined_func_exists == false) {
    log("‚úÖ Successfully detected non-existent function")
} else {
    log("‚ö†Ô∏è  Function check failed")
}

// Memory safety demonstration
fn safe_array_operations() {
    let data = [1, 2, 3, 4, 5]
    // Calculate sum without loops to avoid VM issues
    let sum = data[0] + data[1] + data[2] + data[3] + data[4]
    return sum
}

log("\n6Ô∏è‚É£  Memory Safety Test:")
let array_sum = safe_array_operations()
log("‚úÖ Safe array sum: " + str(array_sum))

log("\n==================================================")
log("‚úÖ Error Handling Demo Complete!")
log("==================================================")

log("\nüõ°Ô∏è Summary:")
log("‚Ä¢ Defensive programming prevents runtime errors")
log("‚Ä¢ Input validation catches type mismatches")
log("‚Ä¢ Bounds checking prevents array access errors")
log("‚Ä¢ Null checks handle missing values gracefully")
log("‚Ä¢ Safe iterations avoid infinite loops")
log("‚Ä¢ Application continues running with proper error handling")