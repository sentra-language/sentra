#!/usr/bin/env sentra

log("üß† Sentra Memory Forensics Demo")
log("===============================")

// List all running processes
log("\nüìã Process Enumeration")
log("---------------------")
let processes = mem_enum_processes()
log("Total processes found: " + str(len(processes)))

// Show first few processes
let limit = 5
for (let i = 0; i < len(processes) && i < limit; i = i + 1) {
    let proc = processes[i]
    log("PID " + str(proc["pid"]) + ": " + proc["name"])
}

// Find specific process by name
log("\nüîç Find Process by Name")
log("-----------------------")
let explorer_procs = mem_find_process("explorer.exe")
if (len(explorer_procs) > 0) {
    let proc = explorer_procs[0]
    log("Found explorer.exe: PID " + str(proc["pid"]))
    
    // Get detailed process information
    let detailed = mem_get_process_info(proc["pid"])
    if (detailed) {
        log("  Path: " + detailed["path"])
        log("  Command Line: " + detailed["command_line"])
        log("  Parent PID: " + str(detailed["parent_pid"]))
        
        // Memory information
        if (detailed["memory"]) {
            let mem = detailed["memory"]
            log("  Working Set: " + str(mem["working_set_size"]) + " bytes")
            log("  Virtual Size: " + str(mem["virtual_size"]) + " bytes")
        }
    }
} else {
    log("Explorer.exe not found")
}

// Analyze process tree
log("\nüå≥ Process Tree Analysis")
log("------------------------")
let tree = mem_get_process_tree()
if (tree) {
    log("Total processes in tree: " + str(tree["total"]))
    
    // Show root processes
    let roots = tree["roots"]
    log("Root processes: " + str(roots))
    if (tree["tree"]) {
        let root_trees = tree["tree"]
        for (let i = 0; i < len(root_trees) && i < 3; i = i + 1) {
            let root = root_trees[i]
            let children = root["children"]
            let child_count = 0
            if (children) {
                child_count = len(children)
            }
            log("  Root PID " + str(root["pid"]) + ": " + root["name"] + " (" + str(child_count) + " children)")
        }
    }
}

// Memory region analysis for current process
log("\nüó∫Ô∏è  Memory Region Analysis")
log("-------------------------")
let current_pid = 1234 // Use explorer.exe PID as example
let regions = mem_get_regions(current_pid)
if (regions && len(regions) > 0) {
    log("Memory regions for PID " + str(current_pid) + ":")
    let region_limit = 3
    for (let i = 0; i < len(regions) && i < region_limit; i = i + 1) {
        let region = regions[i]
        log("  Region " + str(i + 1) + ":")
        log("    Base: " + region["base_address"])
        log("    Size: " + str(region["size"]) + " bytes")
        log("    Protection: " + region["protection"])
        log("    State: " + region["state"])
        log("    Type: " + region["type"])
    }
} else {
    log("No memory regions found or access denied")
}

// Process hollowing detection
log("\nüï≥Ô∏è  Process Hollowing Detection")
log("------------------------------")
if (len(explorer_procs) > 0) {
    let pid = explorer_procs[0]["pid"]
    let hollowing = mem_detect_hollowing(pid)
    if (hollowing) {
        if (hollowing["detected"]) {
            log("‚ö†Ô∏è  Process hollowing detected in PID " + str(pid))
            let indicators = hollowing["indicators"]
            for (let i = 0; i < len(indicators); i = i + 1) {
                log("  - " + indicators[i])
            }
        } else {
            log("‚úÖ No process hollowing detected in PID " + str(pid))
        }
    }
}

// Code injection analysis
log("\nüíâ Code Injection Analysis")
log("--------------------------")
if (len(explorer_procs) > 0) {
    let pid = explorer_procs[0]["pid"]
    let injection_findings = mem_analyze_injection(pid)
    if (injection_findings && len(injection_findings) > 0) {
        log("‚ö†Ô∏è  Code injection indicators found:")
        for (let i = 0; i < len(injection_findings); i = i + 1) {
            log("  - " + injection_findings[i])
        }
    } else {
        log("‚úÖ No code injection indicators found")
    }
}

// Malware scanning
log("\nü¶† Memory Malware Scanning")
log("--------------------------")
if (len(explorer_procs) > 0) {
    let pid = explorer_procs[0]["pid"]
    let malware_detections = mem_scan_malware(pid)
    if (malware_detections && len(malware_detections) > 0) {
        log("üö® MALWARE DETECTED:")
        for (let i = 0; i < len(malware_detections); i = i + 1) {
            log("  - " + malware_detections[i])
        }
    } else {
        log("‚úÖ No malware signatures detected")
    }
}

// Child process analysis
log("\nüë∂ Child Process Analysis")
log("-------------------------")
if (len(explorer_procs) > 0) {
    let parent_pid = explorer_procs[0]["pid"]
    let children = mem_get_children(parent_pid)
    if (children && len(children) > 0) {
        log("Child processes of PID " + str(parent_pid) + ":")
        for (let i = 0; i < len(children); i = i + 1) {
            let child = children[i]
            log("  Child PID " + str(child["pid"]) + ": " + child["name"])
        }
    } else {
        log("No child processes found")
    }
}

log("\n‚úÖ Memory forensics analysis completed!")
log("   This demo showcased:")
log("   ‚Ä¢ Process enumeration and detailed information")
log("   ‚Ä¢ Process tree analysis")
log("   ‚Ä¢ Memory region inspection")
log("   ‚Ä¢ Process hollowing detection")
log("   ‚Ä¢ Code injection analysis")
log("   ‚Ä¢ Memory-based malware scanning")
log("   ‚Ä¢ Parent-child relationship analysis")

// Helper functions (stubs for demo)
fn mem_enum_processes() {
    return [
        {"pid": 1234, "name": "explorer.exe", "path": "C:\\Windows\\explorer.exe", "ppid": 0, "workingset": 102400000, "virtualsize": 204800000},
        {"pid": 5678, "name": "chrome.exe", "path": "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe", "ppid": 1234, "workingset": 512000000, "virtualsize": 1024000000},
        {"pid": 9012, "name": "notepad.exe", "path": "C:\\Windows\\System32\\notepad.exe", "ppid": 1234, "workingset": 8192000, "virtualsize": 16384000},
        {"pid": 3456, "name": "svchost.exe", "path": "C:\\Windows\\System32\\svchost.exe", "ppid": 0, "workingset": 40960000, "virtualsize": 81920000}
    ]
}

fn mem_find_process(name) {
    let processes = mem_enum_processes()
    let result = []
    for (let i = 0; i < len(processes); i = i + 1) {
        if (processes[i]["name"] == name) {
            result = result + [processes[i]]
        }
    }
    return result
}

fn mem_get_process_tree() {
    return {
        "total": 4,
        "roots": 2,
        "tree": [
            {"pid": 1234, "name": "explorer.exe", "children": [5678, 9012]},
            {"pid": 3456, "name": "svchost.exe", "children": []}
        ]
    }
}

fn mem_get_regions(pid) {
    return [
        {"base": "0x00400000", "size": 1048576, "protection": "RX", "state": "Commit", "type": "Image"},
        {"base": "0x00500000", "size": 65536, "protection": "RW", "state": "Commit", "type": "Private"}
    ]
}

fn mem_detect_hollowing(pid) {
    return false
}

fn mem_detect_injection(pid) {
    return []
}

fn mem_scan_malware(pid) {
    return []
}

fn mem_get_children(pid) {
    if (pid == 1234) {
        return [
            {"pid": 5678, "name": "chrome.exe"},
            {"pid": 9012, "name": "notepad.exe"}
        ]
    }
    return []
}