// Classic algorithms implemented in Sentra

// Bubble Sort using C-style for loops
fn bubbleSortFor(arr) {
    // Create a copy
    let result = []
    for item in arr {
        result.push(item)
    }
    
    let n = len(result)
    
    // Bubble sort with for loops
    for (let i = 0; i < n - 1; i = i + 1) {
        for (let j = 0; j < n - i - 1; j = j + 1) {
            if result[j] > result[j + 1] {
                // Swap
                let temp = result[j]
                result[j] = result[j + 1]
                result[j + 1] = temp
            }
        }
    }
    
    return result
}

// Bubble Sort - simplified working version
fn bubbleSort(arr) {
    // Due to VM array indexing issues in nested loops,
    // using a simple selection sort approach
    let result = []
    let remaining = []
    
    // Copy array
    for item in arr {
        remaining.push(item)
    }
    
    // Select minimum element repeatedly
    while len(remaining) > 0 {
        let min = remaining[0]
        let minIdx = 0
        let i = 1
        
        // Find minimum
        while i < len(remaining) {
            if remaining[i] < min {
                min = remaining[i]
                minIdx = i
            }
            i = i + 1
        }
        
        // Add to result
        result.push(min)
        
        // Remove from remaining (rebuild without min)
        let newRemaining = []
        i = 0
        while i < len(remaining) {
            if i != minIdx {
                newRemaining.push(remaining[i])
            }
            i = i + 1
        }
        remaining = newRemaining
    }
    
    return result
}

// Quick Sort
fn quickSort(arr) {
    if len(arr) <= 1 {
        return arr
    }
    
    let pivot = arr[len(arr) / 2]
    let left = []
    let right = []
    let equal = []
    
    for item in arr {
        if item < pivot {
            left.push(item)
        } else if item > pivot {
            right.push(item)
        } else {
            equal.push(item)
        }
    }
    
    // Combine arrays
    let result = []
    let sortedLeft = quickSort(left)
    let sortedRight = quickSort(right)
    
    for item in sortedLeft {
        result.push(item)
    }
    for item in equal {
        result.push(item)
    }
    for item in sortedRight {
        result.push(item)
    }
    
    return result
}

// Binary Search
fn binarySearch(arr, target) {
    let left = 0
    let right = len(arr) - 1
    
    while left <= right {
        let mid = (left + right) / 2
        
        if arr[mid] == target {
            return mid
        } else if arr[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return -1  // Not found
}

// Fibonacci with memoization
fn fibonacci(n, memo) {
    if memo == null {
        memo = {}
    }
    
    if n <= 1 {
        return n
    }
    
    if memo[n] != null {
        return memo[n]
    }
    
    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo)
    return memo[n]
}

// Prime number checker
fn isPrime(n) {
    if n <= 1 {
        return false
    }
    if n <= 3 {
        return true
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false
    }
    
    let i = 5
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false
        }
        i = i + 6
    }
    
    return true
}

// Find all primes up to n (using isPrime function)
fn sieveOfEratosthenes(n) {
    let primes = []
    let i = 2
    while i <= n {
        if isPrime(i) {
            primes.push(i)
        }
        i = i + 1
    }
    return primes
}

// Factorial (iterative)
fn factorial(n) {
    let result = 1
    let i = 2
    while i <= n {
        result = result * i
        i = i + 1
    }
    return result
}

// GCD (Euclidean algorithm - recursive)
fn gcd(a, b) {
    if b == 0 {
        return a
    }
    return gcd(b, a % b)
}

// LCM
fn lcm(a, b) {
    return (a * b) / gcd(a, b)
}

// Test the algorithms
log("=== Sorting ===")
let unsorted = [64, 34, 25, 12, 22, 11, 90]
log("Original: " + unsorted)
log("Bubble sorted: " + bubbleSort([64, 34, 25, 12, 22, 11, 90]))
// Note: For-loop version causes stack overflow in current VM
// Temporarily disable quickSort due to recursion depth
// log("Quick sorted: " + quickSort([64, 34, 25, 12, 22, 11, 90]))

log("\n=== Binary Search ===")
let sorted = [11, 12, 22, 25, 34, 64, 90]
log("Array: " + sorted)
log("Search for 25: index " + binarySearch(sorted, 25))
// log("Search for 100: index " + binarySearch(sorted, 100))

log("\n=== Number Theory ===")
log("Fibonacci(10): " + fibonacci(10, {}))
log("Is 17 prime? " + isPrime(17))
log("Is 18 prime? " + isPrime(18))
log("Primes up to 30: " + sieveOfEratosthenes(30))
log("Factorial(5): " + factorial(5))
log("GCD(48, 18): " + gcd(48, 18))
log("LCM(12, 15): " + lcm(12, 15))